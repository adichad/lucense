/* Generated By:JavaCC: Do not edit this line. SimpleScoringQueryParser.java */
package org.apache.lucene.queryParser;

import java.io.IOException;
import java.io.StringReader;
import java.text.Collator;
import java.text.DateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Vector;

import org.apache.lucene.analysis.Analyzer;
import org.apache.lucene.analysis.CachingTokenFilter;
import org.apache.lucene.analysis.TokenStream;
import org.apache.lucene.analysis.tokenattributes.PositionIncrementAttribute;
import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
import org.apache.lucene.document.DateField;
import org.apache.lucene.document.DateTools;
import org.apache.lucene.index.Term;
import org.apache.lucene.search.BooleanClause;
import org.apache.lucene.search.CustomBooleanQuery;
import org.apache.lucene.search.CustomMultiTermQuery;
import org.apache.lucene.search.CustomPhraseQuery;
import org.apache.lucene.search.CustomPrefixQuery;
import org.apache.lucene.search.CustomTermQuery;
import org.apache.lucene.search.CustomTermRangeQuery;
import org.apache.lucene.search.CustomWildcardQuery;
import org.apache.lucene.search.FuzzyQuery;
import org.apache.lucene.search.MatchAllDocsQuery;
import org.apache.lucene.search.MultiPhraseQuery;
import org.apache.lucene.search.PhraseQuery;
import org.apache.lucene.search.Query;
import org.apache.lucene.search.TermDocsFactory;
import org.apache.lucene.search.TermRangeQuery;
import org.apache.lucene.util.Parameter;
import org.apache.lucene.util.Version;

/**
 * This class is generated by JavaCC. The most important method is
 * {@link #parse(String)}. The syntax for query strings is as follows: A Query
 * is a series of clauses. A clause may be prefixed by:
 * <ul>
 * <li>a plus (<code>+</code>) or a minus (<code>-</code>) sign, indicating that
 * the clause is required or prohibited respectively; or
 * <li>a term followed by a colon, indicating the field to be searched. This
 * enables one to construct queries which search multiple fields.
 * </ul>
 * A clause may be either:
 * <ul>
 * <li>a term, indicating all the documents that contain this term; or
 * <li>a nested query, enclosed in parentheses. Note that this may be used with
 * a <code>+</code>/<code>-</code> prefix to require any of a set of terms.
 * </ul>
 * Thus, in BNF, the query grammar is:
 * 
 * <pre>
 *   Query  ::= ( Clause )*
 *   Clause ::= ["+", "-"] [&lt;TERM&gt; ":"] ( &lt;TERM&gt; | "(" Query ")" )
 * </pre>
 * <p>
 * Examples of appropriately formatted queries can be found in the <a
 * href="../../../../../../queryparsersyntax.html">query syntax
 * documentation</a>.
 * </p>
 * <p>
 * In {@link TermRangeQuery}s, SimpleScoringQueryParser tries to detect date
 * values, e.g. <tt>date:[6/1/2005 TO 6/4/2005]</tt> produces a range query that
 * searches for "date" fields between 2005-06-01 and 2005-06-04. Note that the
 * format of the accepted input depends on {@link #setLocale(Locale) the locale}
 * . By default a date is converted into a search term using the deprecated
 * {@link DateField} for compatibility reasons. To use the new {@link DateTools}
 * to convert dates, a {@link org.apache.lucene.document.DateTools.Resolution}
 * has to be set.
 * </p>
 * <p>
 * The date resolution that shall be used for RangeQueries can be set using
 * {@link #setDateResolution(DateTools.Resolution)} or
 * {@link #setDateResolution(String, DateTools.Resolution)}. The former sets the
 * default date resolution for all fields, whereas the latter can be used to set
 * field specific date resolutions. Field specific date resolutions take, if
 * set, precedence over the default date resolution.
 * </p>
 * <p>
 * If you use neither {@link DateField} nor {@link DateTools} in your index, you
 * can create your own query parser that inherits SimpleScoringQueryParser and
 * overwrites {@link #getRangeQuery(String, String, String, boolean)} to use a
 * different method for date conversion.
 * </p>
 * <p>
 * Note that SimpleScoringQueryParser is <em>not</em> thread-safe.
 * </p>
 * <p>
 * <b>NOTE</b>: there is a new SimpleScoringQueryParser in contrib, which
 * matches the same syntax as this class, but is more modular, enabling
 * substantial customization to how a query is created.
 */
public class SimpleScoringQueryParser implements QueryParserConstants {

  private static final int CONJ_NONE = 0;

  private static final int CONJ_AND = 1;

  private static final int CONJ_OR = 2;

  private static final int MOD_NONE = 0;

  private static final int MOD_NOT = 10;

  private static final int MOD_REQ = 11;

  // make it possible to call setDefaultOperator() without accessing
  // the nested class:
  /** Alternative form of SimpleScoringQueryParser.Operator.AND */
  public static final Operator AND_OPERATOR = Operator.AND;

  /** Alternative form of SimpleScoringQueryParser.Operator.OR */
  public static final Operator OR_OPERATOR = Operator.OR;

  /** The actual operator that parser uses to combine query terms */
  private Operator operator = OR_OPERATOR;

  boolean lowercaseExpandedTerms = true;

  CustomMultiTermQuery.RewriteMethod multiTermRewriteMethod = CustomMultiTermQuery.CONSTANT_SCORE_AUTO_REWRITE_DEFAULT;

  boolean allowLeadingWildcard = false;

  boolean enablePositionIncrements = true;

  Analyzer analyzer;

  String field;

  int phraseSlop = 0;

  float fuzzyMinSim = FuzzyQuery.defaultMinSimilarity;

  int fuzzyPrefixLength = FuzzyQuery.defaultPrefixLength;

  Locale locale = Locale.getDefault();

  // the default date resolution
  DateTools.Resolution dateResolution = null;

  // maps field names to date resolutions
  Map fieldToDateResolution = null;

  // The collator to use when determining range inclusion,
  // for use when constructing RangeQuerys.
  Collator rangeCollator = null;

  private Map<String, Integer> qpos = new HashMap<String, Integer>();

  /**
   * The default operator for parsing queries. Use
   * {@link SimpleScoringQueryParser#setDefaultOperator} to change it.
   */
  static public final class Operator extends Parameter {
    private Operator(String name) {
      super(name);
    }

    static public final Operator OR = new Operator("OR");

    static public final Operator AND = new Operator("AND");
  }

  /**
   * Constructs a query parser.
   * 
   * @param f
   *          the default field for query terms.
   * @param a
   *          used to find terms in the query text.
   * @deprecated Use {@link #QueryParser(Version, String, Analyzer)} instead
   */
  @Deprecated
  public SimpleScoringQueryParser(String f, Analyzer a) {
    this(Version.LUCENE_24, f, a);
  }

  /**
   * Constructs a query parser.
   * 
   * @param matchVersion
   *          Lucene version to match. See <a href="#version">above</a>)
   * @param f
   *          the default field for query terms.
   * @param a
   *          used to find terms in the query text.
   */
  public SimpleScoringQueryParser(Version matchVersion, String f, Analyzer a) {
    this(new FastCharStream(new StringReader("")));
    this.analyzer = a;
    this.field = f;
    if (matchVersion.onOrAfter(Version.LUCENE_29)) {
      this.enablePositionIncrements = true;
    } else {
      this.enablePositionIncrements = false;
    }
  }

  /**
   * Parses a query string, returning a {@link org.apache.lucene.search.Query}.
   * 
   * @param query
   *          the query string to be parsed.
   * @throws ParseException
   *           if the parsing fails
   */
  public Query parse(String query) throws ParseException {
    ReInit(new FastCharStream(new StringReader(query)));
    try {
      // TopLevelQuery is a Query followed by the end-of-input (EOF)
      Query res = TopLevelQuery(this.field);
      return res != null ? res : newBooleanQuery(false);
    } catch (ParseException tme) {
      // rethrow to include the original query:
      ParseException e = new ParseException("Cannot parse '" + query + "': " + tme.getMessage());
      e.initCause(tme);
      throw e;
    } catch (TokenMgrError tme) {
      ParseException e = new ParseException("Cannot parse '" + query + "': " + tme.getMessage());
      e.initCause(tme);
      throw e;
    } catch (CustomBooleanQuery.TooManyClauses tmc) {
      ParseException e = new ParseException("Cannot parse '" + query + "': too many boolean clauses");
      e.initCause(tmc);
      throw e;
    }
  }

  /**
   * @return Returns the analyzer.
   */
  public Analyzer getAnalyzer() {
    return this.analyzer;
  }

  /**
   * @return Returns the field.
   */
  public String getField() {
    return this.field;
  }

  /**
   * Get the minimal similarity for fuzzy queries.
   */
  public float getFuzzyMinSim() {
    return this.fuzzyMinSim;
  }

  /**
   * Set the minimum similarity for fuzzy queries. Default is 0.5f.
   */
  public void setFuzzyMinSim(float fuzzyMinSim) {
    this.fuzzyMinSim = fuzzyMinSim;
  }

  /**
   * Get the prefix length for fuzzy queries.
   * 
   * @return Returns the fuzzyPrefixLength.
   */
  public int getFuzzyPrefixLength() {
    return this.fuzzyPrefixLength;
  }

  /**
   * Set the prefix length for fuzzy queries. Default is 0.
   * 
   * @param fuzzyPrefixLength
   *          The fuzzyPrefixLength to set.
   */
  public void setFuzzyPrefixLength(int fuzzyPrefixLength) {
    this.fuzzyPrefixLength = fuzzyPrefixLength;
  }

  /**
   * Sets the default slop for phrases. If zero, then exact phrase matches are
   * required. Default value is zero.
   */
  public void setPhraseSlop(int phraseSlop) {
    this.phraseSlop = phraseSlop;
  }

  /**
   * Gets the default slop for phrases.
   */
  public int getPhraseSlop() {
    return this.phraseSlop;
  }

  /**
   * Set to <code>true</code> to allow leading wildcard characters.
   * <p>
   * When set, <code>*</code> or <code>?</code> are allowed as the first
   * character of a PrefixQuery and WildcardQuery. Note that this can produce
   * very slow queries on big indexes.
   * <p>
   * Default: false.
   */
  public void setAllowLeadingWildcard(boolean allowLeadingWildcard) {
    this.allowLeadingWildcard = allowLeadingWildcard;
  }

  /**
   * @see #setAllowLeadingWildcard(boolean)
   */
  public boolean getAllowLeadingWildcard() {
    return this.allowLeadingWildcard;
  }

  /**
   * Set to <code>true</code> to enable position increments in result query.
   * <p>
   * When set, result phrase and multi-phrase queries will be aware of position
   * increments. Useful when e.g. a StopFilter increases the position increment
   * of the token that follows an omitted token.
   * <p>
   * Default: false.
   */
  public void setEnablePositionIncrements(boolean enable) {
    this.enablePositionIncrements = enable;
  }

  /**
   * @see #setEnablePositionIncrements(boolean)
   */
  public boolean getEnablePositionIncrements() {
    return this.enablePositionIncrements;
  }

  /**
   * Sets the boolean operator of the SimpleScoringQueryParser. In default mode
   * (<code>OR_OPERATOR</code>) terms without any modifiers are considered
   * optional: for example <code>capital of Hungary</code> is equal to
   * <code>capital OR of OR Hungary</code>.<br/>
   * In <code>AND_OPERATOR</code> mode terms are considered to be in
   * conjunction: the above mentioned query is parsed as
   * <code>capital AND of AND Hungary</code>
   */
  public void setDefaultOperator(Operator op) {
    this.operator = op;
  }

  /**
   * Gets implicit operator setting, which will be either AND_OPERATOR or
   * OR_OPERATOR.
   */
  public Operator getDefaultOperator() {
    return this.operator;
  }

  /**
   * Whether terms of wildcard, prefix, fuzzy and range queries are to be
   * automatically lower-cased or not. Default is <code>true</code>.
   */
  public void setLowercaseExpandedTerms(boolean lowercaseExpandedTerms) {
    this.lowercaseExpandedTerms = lowercaseExpandedTerms;
  }

  /**
   * @see #setLowercaseExpandedTerms(boolean)
   */
  public boolean getLowercaseExpandedTerms() {
    return this.lowercaseExpandedTerms;
  }

  /**
   * @deprecated Please use {@link #setMultiTermRewriteMethod} instead.
   */
  @Deprecated
  public void setUseOldRangeQuery(boolean useOldRangeQuery) {
    if (useOldRangeQuery) {
      setMultiTermRewriteMethod(CustomMultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);
    } else {
      setMultiTermRewriteMethod(CustomMultiTermQuery.CONSTANT_SCORE_AUTO_REWRITE_DEFAULT);
    }
  }

  /**
   * @deprecated Please use {@link #getMultiTermRewriteMethod} instead.
   */
  @Deprecated
  public boolean getUseOldRangeQuery() {
    if (getMultiTermRewriteMethod() == CustomMultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE) {
      return true;
    } else {
      return false;
    }
  }

  /**
   * By default SimpleScoringQueryParser uses
   * {@link CustomMultiTermQuery#CONSTANT_SCORE_AUTO_REWRITE_DEFAULT} when
   * creating a PrefixQuery, WildcardQuery or RangeQuery. This implementation is
   * generally preferable because it a) Runs faster b) Does not have the
   * scarcity of terms unduly influence score c) avoids any
   * "TooManyBooleanClauses" exception. However, if your application really
   * needs to use the old-fashioned CustomBooleanQuery expansion rewriting and
   * the above points are not relevant then use this to change the rewrite
   * method.
   */
  public void setMultiTermRewriteMethod(CustomMultiTermQuery.RewriteMethod method) {
    this.multiTermRewriteMethod = method;
  }

  /**
   * @see #setMultiTermRewriteMethod
   */
  public CustomMultiTermQuery.RewriteMethod getMultiTermRewriteMethod() {
    return this.multiTermRewriteMethod;
  }

  /**
   * Set locale used by date range parsing.
   */
  public void setLocale(Locale locale) {
    this.locale = locale;
  }

  /**
   * Returns current locale, allowing access by subclasses.
   */
  public Locale getLocale() {
    return this.locale;
  }

  /**
   * Sets the default date resolution used by RangeQueries for fields for which
   * no specific date resolutions has been set. Field specific resolutions can
   * be set with {@link #setDateResolution(String, DateTools.Resolution)}.
   * 
   * @param dateResolution
   *          the default date resolution to set
   */
  public void setDateResolution(DateTools.Resolution dateResolution) {
    this.dateResolution = dateResolution;
  }

  /**
   * Sets the date resolution used by RangeQueries for a specific field.
   * 
   * @param fieldName
   *          field for which the date resolution is to be set
   * @param dateResolution
   *          date resolution to set
   */
  public void setDateResolution(String fieldName, DateTools.Resolution dateResolution) {
    if (fieldName == null) {
      throw new IllegalArgumentException("Field cannot be null.");
    }

    if (this.fieldToDateResolution == null) {
      // lazily initialize HashMap
      this.fieldToDateResolution = new HashMap();
    }

    this.fieldToDateResolution.put(fieldName, dateResolution);
  }

  /**
   * Returns the date resolution that is used by RangeQueries for the given
   * field. Returns null, if no default or field specific date resolution has
   * been set for the given field.
   */
  public DateTools.Resolution getDateResolution(String fieldName) {
    if (fieldName == null) {
      throw new IllegalArgumentException("Field cannot be null.");
    }

    if (this.fieldToDateResolution == null) {
      // no field specific date resolutions set; return default date resolution
      // instead
      return this.dateResolution;
    }

    DateTools.Resolution resolution = (DateTools.Resolution) this.fieldToDateResolution.get(fieldName);
    if (resolution == null) {
      // no date resolutions set for the given field; return default date
      // resolution instead
      resolution = this.dateResolution;
    }

    return resolution;
  }

  /**
   * Sets the collator used to determine index term inclusion in ranges for
   * RangeQuerys.
   * <p/>
   * <strong>WARNING:</strong> Setting the rangeCollator to a non-null collator
   * using this method will cause every single index Term in the Field
   * referenced by lowerTerm and/or upperTerm to be examined. Depending on the
   * number of index Terms in this Field, the operation could be very slow.
   * 
   * @param rc
   *          the collator to use when constructing RangeQuerys
   */
  public void setRangeCollator(Collator rc) {
    this.rangeCollator = rc;
  }

  /**
   * @return the collator used to determine index term inclusion in ranges for
   *         RangeQuerys.
   */
  public Collator getRangeCollator() {
    return this.rangeCollator;
  }

  /**
   * @deprecated use {@link #addClause(List, int, int, Query)} instead.
   */
  @Deprecated
  protected void addClause(Vector clauses, int conj, int mods, Query q) {
    addClause((List) clauses, conj, mods, q);
  }

  protected void addClause(List clauses, int conj, int mods, Query q) {
    boolean required, prohibited;

    // If this term is introduced by AND, make the preceding term required,
    // unless it's already prohibited
    if ((clauses.size() > 0) && (conj == CONJ_AND)) {
      BooleanClause c = (BooleanClause) clauses.get(clauses.size() - 1);
      if (!c.isProhibited())
        c.setOccur(BooleanClause.Occur.MUST);
    }

    if ((clauses.size() > 0) && (this.operator == AND_OPERATOR) && (conj == CONJ_OR)) {
      // If this term is introduced by OR, make the preceding term optional,
      // unless it's prohibited (that means we leave -a OR b but +a OR b-->a OR
      // b)
      // notice if the input is a OR b, first term is parsed as required;
      // without
      // this modification a OR b would parsed as +a OR b
      BooleanClause c = (BooleanClause) clauses.get(clauses.size() - 1);
      if (!c.isProhibited())
        c.setOccur(BooleanClause.Occur.SHOULD);
    }

    // We might have been passed a null query; the term might have been
    // filtered away by the analyzer.
    if (q == null)
      return;

    if (this.operator == OR_OPERATOR) {
      // We set REQUIRED if we're introduced by AND or +; PROHIBITED if
      // introduced by NOT or -; make sure not to set both.
      prohibited = (mods == MOD_NOT);
      required = (mods == MOD_REQ);
      if ((conj == CONJ_AND) && !prohibited) {
        required = true;
      }
    } else {
      // We set PROHIBITED if we're introduced by NOT or -; We set REQUIRED
      // if not PROHIBITED and not introduced by OR
      prohibited = (mods == MOD_NOT);
      required = (!prohibited && (conj != CONJ_OR));
    }
    if (required && !prohibited)
      clauses.add(newBooleanClause(q, BooleanClause.Occur.MUST));
    else if (!required && !prohibited)
      clauses.add(newBooleanClause(q, BooleanClause.Occur.SHOULD));
    else if (!required && prohibited)
      clauses.add(newBooleanClause(q, BooleanClause.Occur.MUST_NOT));
    else
      throw new RuntimeException("Clause cannot be both required and prohibited");
  }

  /**
   * @exception ParseException
   *              throw in overridden method to disallow
   */
  protected Query getFieldQuery(String field, String queryText, boolean quoted) throws ParseException {
    // Use the analyzer to get all the tokens, and then build a CustomTermQuery,
    // PhraseQuery, or nothing based on the term count

    if (this.qpos.containsKey(field))
      this.qpos.put(field, this.qpos.get(field) + 1);
    else
      this.qpos.put(field, 0);

    TokenStream source;
    try {
      source = this.analyzer.reusableTokenStream(field, new StringReader(queryText));
      source.reset();
    } catch (IOException e) {
      source = this.analyzer.tokenStream(field, new StringReader(queryText));
    }
    CachingTokenFilter buffer = new CachingTokenFilter(source);
    CharTermAttribute termAtt = null;
    PositionIncrementAttribute posIncrAtt = null;
    int numTokens = 0;

    boolean success = false;
    try {
      buffer.reset();
      success = true;
    } catch (IOException e) {
      // success==false if we hit an exception
    }
    if (success) {
      if (buffer.hasAttribute(CharTermAttribute.class)) {
        termAtt = buffer.getAttribute(CharTermAttribute.class);
      }
      if (buffer.hasAttribute(PositionIncrementAttribute.class)) {
        posIncrAtt = buffer.getAttribute(PositionIncrementAttribute.class);
      }
    }

    int positionCount = 0;
    boolean severalTokensAtSamePosition = false;

    boolean hasMoreTokens = false;
    if (termAtt != null) {
      try {
        hasMoreTokens = buffer.incrementToken();
        while (hasMoreTokens) {
          numTokens++;
          int positionIncrement = (posIncrAtt != null) ? posIncrAtt.getPositionIncrement() : 1;
          if (positionIncrement != 0) {
            positionCount += positionIncrement;
          } else {
            severalTokensAtSamePosition = true;
          }
          hasMoreTokens = buffer.incrementToken();
        }
      } catch (IOException e) {
        // ignore
      }
    }
    try {
      // rewind the buffer stream
      buffer.reset();

      // close original stream - all tokens buffered
      source.close();
    } catch (IOException e) {
      // ignore
    }

    if (numTokens == 0)
      return null;
    else if (numTokens == 1) {
      String term = null;
      try {
        boolean hasNext = buffer.incrementToken();
        assert hasNext == true;
        term = termAtt.toString();
      } catch (IOException e) {
        // safe to ignore, because we know the number of tokens
      }
      return newTermQuery(new Term(field, term));
    } else {
      if (severalTokensAtSamePosition) {
        if (positionCount == 1) {
          // no phrase query:
          CustomBooleanQuery q = newBooleanQuery(true);
          for (int i = 0; i < numTokens; i++) {
            String term = null;
            try {
              boolean hasNext = buffer.incrementToken();
              assert hasNext == true;
              term = termAtt.toString();
            } catch (IOException e) {
              // safe to ignore, because we know the number of tokens
            }

            Query currentQuery = newTermQuery(new Term(field, term));
            q.add(currentQuery, BooleanClause.Occur.SHOULD);
          }
          return q;
        } else {
          // phrase query:
          MultiPhraseQuery mpq = newMultiPhraseQuery();
          mpq.setSlop(this.phraseSlop);
          List multiTerms = new ArrayList();
          int position = -1;
          for (int i = 0; i < numTokens; i++) {
            String term = null;
            int positionIncrement = 1;
            try {
              boolean hasNext = buffer.incrementToken();
              assert hasNext == true;
              term = termAtt.toString();
              if (posIncrAtt != null) {
                positionIncrement = posIncrAtt.getPositionIncrement();
              }
            } catch (IOException e) {
              // safe to ignore, because we know the number of tokens
            }

            if ((positionIncrement > 0) && (multiTerms.size() > 0)) {
              if (this.enablePositionIncrements) {

                mpq.add((Term[]) multiTerms.toArray(new Term[0]), position);
              } else {
                mpq.add((Term[]) multiTerms.toArray(new Term[0]));
              }
              multiTerms.clear();
            }
            position += positionIncrement;
            multiTerms.add(new Term(field, term));
          }
          if (this.enablePositionIncrements) {
            mpq.add((Term[]) multiTerms.toArray(new Term[0]), position);
          } else {
            mpq.add((Term[]) multiTerms.toArray(new Term[0]));
          }
          return mpq;
        }
      } else {
        CustomPhraseQuery pq = newPhraseQuery();
        pq.setSlop(this.phraseSlop);
        int position = -1;

        for (int i = 0; i < numTokens; i++) {
          String term = null;
          int positionIncrement = 1;

          try {
            boolean hasNext = buffer.incrementToken();
            assert hasNext == true;
            term = termAtt.toString();
            if (posIncrAtt != null) {
              positionIncrement = posIncrAtt.getPositionIncrement();
            }
          } catch (IOException e) {
            // safe to ignore, because we know the number of tokens
          }

          if (this.enablePositionIncrements) {
            position += positionIncrement;
            pq.add(new Term(field, term), position, this.qpos.get(field));
            if (i < numTokens - 1)
              this.qpos.put(field, this.qpos.get(field) + 1);
          } else {
            pq.add(new Term(field, term), this.qpos.get(field));
            if (i < numTokens - 1)
              this.qpos.put(field, this.qpos.get(field) + 1);
          }
        }
        return pq;
      }
    }
  }

  /**
   * Base implementation delegates to {@link #getFieldQuery(String,String)}.
   * This method may be overridden, for example, to return a SpanNearQuery
   * instead of a PhraseQuery.
   * 
   * @exception ParseException
   *              throw in overridden method to disallow
   */
  protected Query getFieldQuery(String field, String queryText, int slop) throws ParseException {
    Query query = getFieldQuery(field, queryText, true);

    if (query instanceof PhraseQuery) {
      ((PhraseQuery) query).setSlop(slop);
    }
    if (query instanceof MultiPhraseQuery) {
      ((MultiPhraseQuery) query).setSlop(slop);
    }

    return query;
  }

  /**
   * @exception ParseException
   *              throw in overridden method to disallow
   */
  protected Query getRangeQuery(String field, String part1, String part2, boolean inclusive) throws ParseException {
    if (this.lowercaseExpandedTerms) {
      part1 = part1.toLowerCase();
      part2 = part2.toLowerCase();
    }

    if (this.qpos.containsKey(field))
      this.qpos.put(field, this.qpos.get(field) + 1);
    else
      this.qpos.put(field, 0);

    try {
      DateFormat df = DateFormat.getDateInstance(DateFormat.SHORT, this.locale);
      df.setLenient(true);
      Date d1 = df.parse(part1);
      Date d2 = df.parse(part2);
      if (inclusive) {
        // The user can only specify the date, not the time, so make sure
        // the time is set to the latest possible time of that date to really
        // include all documents:
        Calendar cal = Calendar.getInstance(this.locale);
        cal.setTime(d2);
        cal.set(Calendar.HOUR_OF_DAY, 23);
        cal.set(Calendar.MINUTE, 59);
        cal.set(Calendar.SECOND, 59);
        cal.set(Calendar.MILLISECOND, 999);
        d2 = cal.getTime();
      }
      DateTools.Resolution resolution = getDateResolution(field);
      if (resolution == null) {
        // no default or field specific date resolution has been set,
        // use deprecated DateField to maintain compatibilty with
        // pre-1.9 Lucene versions.
        part1 = DateField.dateToString(d1);
        part2 = DateField.dateToString(d2);
      } else {
        part1 = DateTools.dateToString(d1, resolution);
        part2 = DateTools.dateToString(d2, resolution);
      }
    } catch (Exception e) {
    }

    return newRangeQuery(field, part1, part2, inclusive);
  }

  protected CustomBooleanQuery newBooleanQuery(boolean disableCoord) {
    return new CustomBooleanQuery(disableCoord);
  }

  protected BooleanClause newBooleanClause(Query q, BooleanClause.Occur occur) {
    return new BooleanClause(q, occur);// no need to change: adichad
  }

  protected CustomTermQuery newTermQuery(Term term) {
    return new CustomTermQuery(term, this.qpos.get(term.field()), this.termDocsFactory);
  }

  protected CustomPhraseQuery newPhraseQuery() {
    return new CustomPhraseQuery(this.termDocsFactory);
  }

  protected MultiPhraseQuery newMultiPhraseQuery() {
    return new MultiPhraseQuery();
  }

  protected Query newPrefixQuery(Term prefix) {
    CustomPrefixQuery query = new CustomPrefixQuery(prefix, this.qpos.get(prefix.field()));
    query.setRewriteMethod(this.multiTermRewriteMethod);
    return query;
  }

  protected Query newFuzzyQuery(Term term, float minimumSimilarity, int prefixLength) {
    // FuzzyQuery doesn't yet allow constant score rewrite
    return new FuzzyQuery(term, minimumSimilarity, prefixLength);
  }

  protected Query newRangeQuery(String field, String part1, String part2, boolean inclusive) {
    final CustomTermRangeQuery query = new CustomTermRangeQuery(field, part1, part2, inclusive, inclusive,
        this.rangeCollator, this.qpos.get(field));
    query.setRewriteMethod(this.multiTermRewriteMethod);
    return query;
  }

  protected Query newMatchAllDocsQuery() {
    return new MatchAllDocsQuery();
  }

  protected Query newWildcardQuery(Term t) {
    CustomWildcardQuery query = new CustomWildcardQuery(t, this.qpos.get(t.field()));
    query.setRewriteMethod(this.multiTermRewriteMethod);
    return query;
  }

  /**
   * Factory method for generating query, given a set of clauses. By default
   * creates a boolean query composed of clauses passed in. Can be overridden by
   * extending classes, to modify query being returned.
   * 
   * @param clauses
   *          List that contains {@link BooleanClause} instances to join.
   * @return Resulting {@link Query} object.
   * @exception ParseException
   *              throw in overridden method to disallow
   * @deprecated use {@link #getBooleanQuery(List)} instead
   */
  @Deprecated
  protected Query getBooleanQuery(Vector clauses) throws ParseException {
    return getBooleanQuery((List) clauses, false);
  }

  /**
   * Factory method for generating query, given a set of clauses. By default
   * creates a boolean query composed of clauses passed in. Can be overridden by
   * extending classes, to modify query being returned.
   * 
   * @param clauses
   *          List that contains {@link BooleanClause} instances to join.
   * @return Resulting {@link Query} object.
   * @exception ParseException
   *              throw in overridden method to disallow
   */
  protected Query getBooleanQuery(List clauses) throws ParseException {
    return getBooleanQuery(clauses, false);
  }

  /**
   * Factory method for generating query, given a set of clauses. By default
   * creates a boolean query composed of clauses passed in. Can be overridden by
   * extending classes, to modify query being returned.
   * 
   * @param clauses
   *          List that contains {@link BooleanClause} instances to join.
   * @param disableCoord
   *          true if coord scoring should be disabled.
   * @return Resulting {@link Query} object.
   * @exception ParseException
   *              throw in overridden method to disallow
   * @deprecated use {@link #getBooleanQuery(List, boolean)} instead
   */
  @Deprecated
  protected Query getBooleanQuery(Vector clauses, boolean disableCoord) throws ParseException {
    return getBooleanQuery((List) clauses, disableCoord);
  }

  /**
   * Factory method for generating query, given a set of clauses. By default
   * creates a boolean query composed of clauses passed in. Can be overridden by
   * extending classes, to modify query being returned.
   * 
   * @param clauses
   *          List that contains {@link BooleanClause} instances to join.
   * @param disableCoord
   *          true if coord scoring should be disabled.
   * @return Resulting {@link Query} object.
   * @exception ParseException
   *              throw in overridden method to disallow
   */
  protected Query getBooleanQuery(List clauses, boolean disableCoord) throws ParseException {
    if (clauses.size() == 0) {
      return null; // all clause words were filtered away by the analyzer.
    }
    CustomBooleanQuery query = newBooleanQuery(disableCoord);
    for (int i = 0; i < clauses.size(); i++) {
      query.add((BooleanClause) clauses.get(i));
    }
    return query;
  }

  /**
   * Factory method for generating a query. Called when parser parses an input
   * term token that contains one or more wildcard characters (? and *), but is
   * not a prefix term token (one that has just a single * character at the end)
   * <p>
   * Depending on settings, prefix term may be lower-cased automatically. It
   * will not go through the default Analyzer, however, since normal Analyzers
   * are unlikely to work properly with wildcard templates.
   * <p>
   * Can be overridden by extending classes, to provide custom handling for
   * wildcard queries, which may be necessary due to missing analyzer calls.
   * 
   * @param field
   *          Name of the field query will use.
   * @param termStr
   *          Term token that contains one or more wild card characters (? or
   *          *), but is not simple prefix term
   * @return Resulting {@link Query} built for the term
   * @exception ParseException
   *              throw in overridden method to disallow
   */
  protected Query getWildcardQuery(String field, String termStr) throws ParseException {
    if ("*".equals(field)) {
      if ("*".equals(termStr))
        return newMatchAllDocsQuery();
    }
    if (!this.allowLeadingWildcard && (termStr.startsWith("*") || termStr.startsWith("?")))
      throw new ParseException("'*' or '?' not allowed as first character in WildcardQuery");
    if (this.lowercaseExpandedTerms) {
      termStr = termStr.toLowerCase();
    }
    Term t = new Term(field, termStr);
    return newWildcardQuery(t);
  }

  /**
   * Factory method for generating a query (similar to {@link #getWildcardQuery}
   * ). Called when parser parses an input term token that uses prefix notation;
   * that is, contains a single '*' wildcard character as its last character.
   * Since this is a special case of generic wildcard term, and such a query can
   * be optimized easily, this usually results in a different query object.
   * <p>
   * Depending on settings, a prefix term may be lower-cased automatically. It
   * will not go through the default Analyzer, however, since normal Analyzers
   * are unlikely to work properly with wildcard templates.
   * <p>
   * Can be overridden by extending classes, to provide custom handling for wild
   * card queries, which may be necessary due to missing analyzer calls.
   * 
   * @param field
   *          Name of the field query will use.
   * @param termStr
   *          Term token to use for building term for the query (<b>without</b>
   *          trailing '*' character!)
   * @return Resulting {@link Query} built for the term
   * @exception ParseException
   *              throw in overridden method to disallow
   */
  protected Query getPrefixQuery(String field, String termStr) throws ParseException {
    if (!this.allowLeadingWildcard && termStr.startsWith("*"))
      throw new ParseException("'*' not allowed as first character in PrefixQuery");
    if (this.lowercaseExpandedTerms) {
      termStr = termStr.toLowerCase();
    }
    Term t = new Term(field, termStr);
    return newPrefixQuery(t);
  }

  /**
   * Factory method for generating a query (similar to {@link #getWildcardQuery}
   * ). Called when parser parses an input term token that has the fuzzy suffix
   * (~) appended.
   * 
   * @param field
   *          Name of the field query will use.
   * @param termStr
   *          Term token to use for building term for the query
   * @return Resulting {@link Query} built for the term
   * @exception ParseException
   *              throw in overridden method to disallow
   */
  protected Query getFuzzyQuery(String field, String termStr, float minSimilarity) throws ParseException {
    if (this.lowercaseExpandedTerms) {
      termStr = termStr.toLowerCase();
    }
    Term t = new Term(field, termStr);
    return newFuzzyQuery(t, minSimilarity, this.fuzzyPrefixLength);
  }

  /**
   * Returns a String where the escape char has been removed, or kept only once
   * if there was a double escape. Supports escaped unicode characters, e. g.
   * translates <code>\\u0041</code> to <code>A</code>.
   */
  private String discardEscapeChar(String input) throws ParseException {
    // Create char array to hold unescaped char sequence
    char[] output = new char[input.length()];

    // The length of the output can be less than the input
    // due to discarded escape chars. This variable holds
    // the actual length of the output
    int length = 0;

    // We remember whether the last processed character was
    // an escape character
    boolean lastCharWasEscapeChar = false;

    // The multiplier the current unicode digit must be multiplied with.
    // E. g. the first digit must be multiplied with 16^3, the second with
    // 16^2...
    int codePointMultiplier = 0;

    // Used to calculate the codepoint of the escaped unicode character
    int codePoint = 0;

    for (int i = 0; i < input.length(); i++) {
      char curChar = input.charAt(i);
      if (codePointMultiplier > 0) {
        codePoint += hexToInt(curChar) * codePointMultiplier;
        codePointMultiplier >>>= 4;
        if (codePointMultiplier == 0) {
          output[length++] = (char) codePoint;
          codePoint = 0;
        }
      } else if (lastCharWasEscapeChar) {
        if (curChar == 'u') {
          // found an escaped unicode character
          codePointMultiplier = 16 * 16 * 16;
        } else {
          // this character was escaped
          output[length] = curChar;
          length++;
        }
        lastCharWasEscapeChar = false;
      } else {
        if (curChar == '\\') {
          lastCharWasEscapeChar = true;
        } else {
          output[length] = curChar;
          length++;
        }
      }
    }

    if (codePointMultiplier > 0) {
      throw new ParseException("Truncated unicode escape sequence.");
    }

    if (lastCharWasEscapeChar) {
      throw new ParseException("Term can not end with escape character.");
    }

    return new String(output, 0, length);
  }

  /** Returns the numeric value of the hexadecimal character */
  private static final int hexToInt(char c) throws ParseException {
    if (('0' <= c) && (c <= '9')) {
      return c - '0';
    } else if (('a' <= c) && (c <= 'f')) {
      return c - 'a' + 10;
    } else if (('A' <= c) && (c <= 'F')) {
      return c - 'A' + 10;
    } else {
      throw new ParseException("None-hex character in unicode escape sequence: " + c);
    }
  }

  /**
   * Returns a String where those characters that SimpleScoringQueryParser
   * expects to be escaped are escaped by a preceding <code>\</code>.
   */
  public static String escape(String s) {
    StringBuffer sb = new StringBuffer();
    for (int i = 0; i < s.length(); i++) {
      char c = s.charAt(i);
      // These characters are part of the query syntax and must be escaped
      if ((c == '\\') || (c == '+') || (c == '-') || (c == '!') || (c == '(') || (c == ')') || (c == ':') || (c == '^')
          || (c == '[') || (c == ']') || (c == '\"') || (c == '{') || (c == '}') || (c == '~') || (c == '*')
          || (c == '?') || (c == '|') || (c == '&')) {
        sb.append('\\');
      }
      sb.append(c);
    }
    return sb.toString();
  }

  /**
   * Command line tool to test SimpleScoringQueryParser, using
   * {@link org.apache.lucene.analysis.SimpleAnalyzer}. Usage:<br>
   * <code>java org.apache.lucene.queryParser.SimpleScoringQueryParser &lt;input&gt;</code>
   */
  public static void main(String[] args) throws Exception {
    if (args.length == 0) {
      System.out.println("Usage: java org.apache.lucene.queryParser.SimpleScoringQueryParser <input>");
      System.exit(0);
    }
    SimpleScoringQueryParser qp = new SimpleScoringQueryParser("field", new org.apache.lucene.analysis.SimpleAnalyzer());
    Query q = qp.parse(args[0]);
    System.out.println(q.toString("field"));
  }

  // * Query ::= ( Clause )*
  // * Clause ::= ["+", "-"] [<TERM> ":"] ( <TERM> | "(" Query ")" )
  final public int Conjunction() throws ParseException {
    int ret = CONJ_NONE;
    switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
    case AND:
    case OR:
      switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
      case AND:
        jj_consume_token(AND);
        ret = CONJ_AND;
        break;
      case OR:
        jj_consume_token(OR);
        ret = CONJ_OR;
        break;
      default:
        this.jj_la1[0] = this.jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      this.jj_la1[1] = this.jj_gen;
      ;
    }
    {
      if (true)
        return ret;
    }
    throw new Error("Missing return statement in function");
  }

  final public int Modifiers() throws ParseException {
    int ret = MOD_NONE;
    switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
    case NOT:
    case PLUS:
    case MINUS:
      switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
      case PLUS:
        jj_consume_token(PLUS);
        ret = MOD_REQ;
        break;
      case MINUS:
        jj_consume_token(MINUS);
        ret = MOD_NOT;
        break;
      case NOT:
        jj_consume_token(NOT);
        ret = MOD_NOT;
        break;
      default:
        this.jj_la1[2] = this.jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      this.jj_la1[3] = this.jj_gen;
      ;
    }
    {
      if (true)
        return ret;
    }
    throw new Error("Missing return statement in function");
  }

  // This makes sure that there is no garbage after the query string
  final public Query TopLevelQuery(String field) throws ParseException {
    Query q;
    q = Query(field);
    jj_consume_token(0);
    {
      if (true)
        return q;
    }
    throw new Error("Missing return statement in function");
  }

  final public Query Query(String field) throws ParseException {
    List clauses = new ArrayList();
    Query q, firstQuery = null;
    int conj, mods;
    mods = Modifiers();
    q = Clause(field);
    addClause(clauses, CONJ_NONE, mods, q);
    if (mods == MOD_NONE)
      firstQuery = q;
    label_1: while (true) {
      switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
      case AND:
      case OR:
      case NOT:
      case PLUS:
      case MINUS:
      case LPAREN:
      case STAR:
      case QUOTED:
      case TERM:
      case PREFIXTERM:
      case WILDTERM:
      case RANGEIN_START:
      case RANGEEX_START:
      case NUMBER:
        ;
        break;
      default:
        this.jj_la1[4] = this.jj_gen;
        break label_1;
      }
      conj = Conjunction();
      mods = Modifiers();
      q = Clause(field);
      addClause(clauses, conj, mods, q);
    }
    if ((clauses.size() == 1) && (firstQuery != null)) {
      if (true)
        return firstQuery;
    } else {
      {
        if (true)
          return getBooleanQuery(clauses);
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public Query Clause(String field) throws ParseException {
    Query q;
    Token fieldToken = null, boost = null;
    if (jj_2_1(2)) {
      switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
      case TERM:
        fieldToken = jj_consume_token(TERM);
        jj_consume_token(COLON);
        field = discardEscapeChar(fieldToken.image);
        break;
      case STAR:
        jj_consume_token(STAR);
        jj_consume_token(COLON);
        field = "*";
        break;
      default:
        this.jj_la1[5] = this.jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } else {
      ;
    }
    switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
    case STAR:
    case QUOTED:
    case TERM:
    case PREFIXTERM:
    case WILDTERM:
    case RANGEIN_START:
    case RANGEEX_START:
    case NUMBER:
      q = Term(field);
      break;
    case LPAREN:
      jj_consume_token(LPAREN);
      q = Query(field);
      jj_consume_token(RPAREN);
      switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
      case CARAT:
        jj_consume_token(CARAT);
        boost = jj_consume_token(NUMBER);
        break;
      default:
        this.jj_la1[6] = this.jj_gen;
        ;
      }
      break;
    default:
      this.jj_la1[7] = this.jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    if (boost != null) {
      float f = (float) 0.0;
      try {
        f = Float.valueOf(boost.image).floatValue();
      } catch (Exception ignored) {
      }
      if (q != null) {
        q.setBoost(f);
      }
    }
    {
      if (true)
        return q;
    }
    throw new Error("Missing return statement in function");
  }

  final public Query Term(String field) throws ParseException {
    Token term, boost = null, fuzzySlop = null, goop1, goop2;
    boolean prefix = false;
    boolean wildcard = false;
    boolean fuzzy = false;
    Query q;
    switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
    case STAR:
    case TERM:
    case PREFIXTERM:
    case WILDTERM:
    case NUMBER:
      switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
      case TERM:
        term = jj_consume_token(TERM);
        break;
      case STAR:
        term = jj_consume_token(STAR);
        wildcard = true;
        break;
      case PREFIXTERM:
        term = jj_consume_token(PREFIXTERM);
        prefix = true;
        break;
      case WILDTERM:
        term = jj_consume_token(WILDTERM);
        wildcard = true;
        break;
      case NUMBER:
        term = jj_consume_token(NUMBER);
        break;
      default:
        this.jj_la1[8] = this.jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
      case FUZZY_SLOP:
        fuzzySlop = jj_consume_token(FUZZY_SLOP);
        fuzzy = true;
        break;
      default:
        this.jj_la1[9] = this.jj_gen;
        ;
      }
      switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
      case CARAT:
        jj_consume_token(CARAT);
        boost = jj_consume_token(NUMBER);
        switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
        case FUZZY_SLOP:
          fuzzySlop = jj_consume_token(FUZZY_SLOP);
          fuzzy = true;
          break;
        default:
          this.jj_la1[10] = this.jj_gen;
          ;
        }
        break;
      default:
        this.jj_la1[11] = this.jj_gen;
        ;
      }
      String termImage = discardEscapeChar(term.image);
      if (wildcard) {
        q = getWildcardQuery(field, termImage);
      } else if (prefix) {
        q = getPrefixQuery(field, discardEscapeChar(term.image.substring(0, term.image.length() - 1)));
      } else if (fuzzy) {
        float fms = this.fuzzyMinSim;
        try {
          fms = Float.valueOf(fuzzySlop.image.substring(1)).floatValue();
        } catch (Exception ignored) {
        }
        if ((fms < 0.0f) || (fms > 1.0f)) {
          {
            if (true)
              throw new ParseException("Minimum similarity for a FuzzyQuery has to be between 0.0f and 1.0f !");
          }
        }
        q = getFuzzyQuery(field, termImage, fms);
      } else {
        q = getFieldQuery(field, termImage, true);
      }
      break;
    case RANGEIN_START:
      jj_consume_token(RANGEIN_START);
      switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
      case RANGEIN_GOOP:
        goop1 = jj_consume_token(RANGEIN_GOOP);
        break;
      case RANGEIN_QUOTED:
        goop1 = jj_consume_token(RANGEIN_QUOTED);
        break;
      default:
        this.jj_la1[12] = this.jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
      case RANGEIN_TO:
        jj_consume_token(RANGEIN_TO);
        break;
      default:
        this.jj_la1[13] = this.jj_gen;
        ;
      }
      switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
      case RANGEIN_GOOP:
        goop2 = jj_consume_token(RANGEIN_GOOP);
        break;
      case RANGEIN_QUOTED:
        goop2 = jj_consume_token(RANGEIN_QUOTED);
        break;
      default:
        this.jj_la1[14] = this.jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(RANGEIN_END);
      switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
      case CARAT:
        jj_consume_token(CARAT);
        boost = jj_consume_token(NUMBER);
        break;
      default:
        this.jj_la1[15] = this.jj_gen;
        ;
      }
      if (goop1.kind == RANGEIN_QUOTED) {
        goop1.image = goop1.image.substring(1, goop1.image.length() - 1);
      }
      if (goop2.kind == RANGEIN_QUOTED) {
        goop2.image = goop2.image.substring(1, goop2.image.length() - 1);
      }
      q = getRangeQuery(field, discardEscapeChar(goop1.image), discardEscapeChar(goop2.image), true);
      break;
    case RANGEEX_START:
      jj_consume_token(RANGEEX_START);
      switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
      case RANGEEX_GOOP:
        goop1 = jj_consume_token(RANGEEX_GOOP);
        break;
      case RANGEEX_QUOTED:
        goop1 = jj_consume_token(RANGEEX_QUOTED);
        break;
      default:
        this.jj_la1[16] = this.jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
      case RANGEEX_TO:
        jj_consume_token(RANGEEX_TO);
        break;
      default:
        this.jj_la1[17] = this.jj_gen;
        ;
      }
      switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
      case RANGEEX_GOOP:
        goop2 = jj_consume_token(RANGEEX_GOOP);
        break;
      case RANGEEX_QUOTED:
        goop2 = jj_consume_token(RANGEEX_QUOTED);
        break;
      default:
        this.jj_la1[18] = this.jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(RANGEEX_END);
      switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
      case CARAT:
        jj_consume_token(CARAT);
        boost = jj_consume_token(NUMBER);
        break;
      default:
        this.jj_la1[19] = this.jj_gen;
        ;
      }
      if (goop1.kind == RANGEEX_QUOTED) {
        goop1.image = goop1.image.substring(1, goop1.image.length() - 1);
      }
      if (goop2.kind == RANGEEX_QUOTED) {
        goop2.image = goop2.image.substring(1, goop2.image.length() - 1);
      }

      q = getRangeQuery(field, discardEscapeChar(goop1.image), discardEscapeChar(goop2.image), false);
      break;
    case QUOTED:
      term = jj_consume_token(QUOTED);
      switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
      case FUZZY_SLOP:
        fuzzySlop = jj_consume_token(FUZZY_SLOP);
        break;
      default:
        this.jj_la1[20] = this.jj_gen;
        ;
      }
      switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
      case CARAT:
        jj_consume_token(CARAT);
        boost = jj_consume_token(NUMBER);
        break;
      default:
        this.jj_la1[21] = this.jj_gen;
        ;
      }
      int s = this.phraseSlop;

      if (fuzzySlop != null) {
        try {
          s = Float.valueOf(fuzzySlop.image.substring(1)).intValue();
        } catch (Exception ignored) {
        }
      }
      q = getFieldQuery(field, discardEscapeChar(term.image.substring(1, term.image.length() - 1)), s);
      break;
    default:
      this.jj_la1[22] = this.jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    if (boost != null) {
      float f = (float) 0.0;
      try {
        f = Float.valueOf(boost.image).floatValue();
      } catch (Exception ignored) {
        /*
         * Should this be handled somehow? (defaults to "no boost", if boost
         * number is invalid)
         */
      }

      // avoid boosting null queries, such as those caused by stop words
      if (q != null) {
        q.setBoost(f);
      }
    }
    {
      if (true)
        return q;
    }
    throw new Error("Missing return statement in function");
  }

  private boolean jj_2_1(int xla) {
    this.jj_la = xla;
    this.jj_lastpos = this.jj_scanpos = this.token;
    try {
      return !jj_3_1();
    } catch (LookaheadSuccess ls) {
      return true;
    } finally {
      jj_save(0, xla);
    }
  }

  private boolean jj_3_1() {
    Token xsp;
    xsp = this.jj_scanpos;
    if (jj_3R_2()) {
      this.jj_scanpos = xsp;
      if (jj_3R_3())
        return true;
    }
    return false;
  }

  private boolean jj_3R_3() {
    if (jj_scan_token(STAR))
      return true;
    if (jj_scan_token(COLON))
      return true;
    return false;
  }

  private boolean jj_3R_2() {
    if (jj_scan_token(TERM))
      return true;
    if (jj_scan_token(COLON))
      return true;
    return false;
  }

  /** Generated Token Manager. */
  public QueryParserTokenManager token_source;

  /** Current token. */
  public Token token;

  /** Next token. */
  public Token jj_nt;

  private int jj_ntk;

  private Token jj_scanpos, jj_lastpos;

  private int jj_la;

  private int jj_gen;

  final private int[] jj_la1 = new int[23];

  static private int[] jj_la1_0;

  static private int[] jj_la1_1;
  static {
    jj_la1_init_0();
    jj_la1_init_1();
  }

  private static void jj_la1_init_0() {
    jj_la1_0 = new int[] { 0x300, 0x300, 0x1c00, 0x1c00, 0x3ed3f00, 0x90000, 0x20000, 0x3ed2000, 0x2690000, 0x100000,
        0x100000, 0x20000, 0x30000000, 0x4000000, 0x30000000, 0x20000, 0x0, 0x40000000, 0x0, 0x20000, 0x100000,
        0x20000, 0x3ed0000, };
  }

  private static void jj_la1_init_1() {
    jj_la1_1 = new int[] { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0,
        0x3, 0x0, 0x0, 0x0, 0x0, };
  }

  final private JJCalls[] jj_2_rtns = new JJCalls[1];

  private boolean jj_rescan = false;

  private int jj_gc = 0;

  /** Constructor with user supplied CharStream. */
  public SimpleScoringQueryParser(CharStream stream) {
    this.token_source = new QueryParserTokenManager(stream);
    this.token = new Token();
    this.jj_ntk = -1;
    this.jj_gen = 0;
    for (int i = 0; i < 23; i++)
      this.jj_la1[i] = -1;
    for (int i = 0; i < this.jj_2_rtns.length; i++)
      this.jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(CharStream stream) {
    this.token_source.ReInit(stream);
    this.token = new Token();
    this.jj_ntk = -1;
    this.jj_gen = 0;
    for (int i = 0; i < 23; i++)
      this.jj_la1[i] = -1;
    for (int i = 0; i < this.jj_2_rtns.length; i++)
      this.jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public SimpleScoringQueryParser(QueryParserTokenManager tm) {
    this.token_source = tm;
    this.token = new Token();
    this.jj_ntk = -1;
    this.jj_gen = 0;
    for (int i = 0; i < 23; i++)
      this.jj_la1[i] = -1;
    for (int i = 0; i < this.jj_2_rtns.length; i++)
      this.jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(QueryParserTokenManager tm) {
    this.token_source = tm;
    this.token = new Token();
    this.jj_ntk = -1;
    this.jj_gen = 0;
    for (int i = 0; i < 23; i++)
      this.jj_la1[i] = -1;
    for (int i = 0; i < this.jj_2_rtns.length; i++)
      this.jj_2_rtns[i] = new JJCalls();
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = this.token).next != null)
      this.token = this.token.next;
    else
      this.token = this.token.next = this.token_source.getNextToken();
    this.jj_ntk = -1;
    if (this.token.kind == kind) {
      this.jj_gen++;
      if (++this.jj_gc > 100) {
        this.jj_gc = 0;
        for (int i = 0; i < this.jj_2_rtns.length; i++) {
          JJCalls c = this.jj_2_rtns[i];
          while (c != null) {
            if (c.gen < this.jj_gen)
              c.first = null;
            c = c.next;
          }
        }
      }
      return this.token;
    }
    this.token = oldToken;
    this.jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error {
  }

  final private LookaheadSuccess jj_ls = new LookaheadSuccess();

  private boolean jj_scan_token(int kind) {
    if (this.jj_scanpos == this.jj_lastpos) {
      this.jj_la--;
      if (this.jj_scanpos.next == null) {
        this.jj_lastpos = this.jj_scanpos = this.jj_scanpos.next = this.token_source.getNextToken();
      } else {
        this.jj_lastpos = this.jj_scanpos = this.jj_scanpos.next;
      }
    } else {
      this.jj_scanpos = this.jj_scanpos.next;
    }
    if (this.jj_rescan) {
      int i = 0;
      Token tok = this.token;
      while ((tok != null) && (tok != this.jj_scanpos)) {
        i++;
        tok = tok.next;
      }
      if (tok != null)
        jj_add_error_token(kind, i);
    }
    if (this.jj_scanpos.kind != kind)
      return true;
    if ((this.jj_la == 0) && (this.jj_scanpos == this.jj_lastpos))
      throw this.jj_ls;
    return false;
  }

  /** Get the next Token. */
  final public Token getNextToken() {
    if (this.token.next != null)
      this.token = this.token.next;
    else
      this.token = this.token.next = this.token_source.getNextToken();
    this.jj_ntk = -1;
    this.jj_gen++;
    return this.token;
  }

  /** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = this.token;
    for (int i = 0; i < index; i++) {
      if (t.next != null)
        t = t.next;
      else
        t = t.next = this.token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((this.jj_nt = this.token.next) == null)
      return (this.jj_ntk = (this.token.next = this.token_source.getNextToken()).kind);
    else
      return (this.jj_ntk = this.jj_nt.kind);
  }

  private java.util.List jj_expentries = new java.util.ArrayList();

  private int[] jj_expentry;

  private int jj_kind = -1;

  private int[] jj_lasttokens = new int[100];

  private int jj_endpos;

  private TermDocsFactory termDocsFactory;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100)
      return;
    if (pos == this.jj_endpos + 1) {
      this.jj_lasttokens[this.jj_endpos++] = kind;
    } else if (this.jj_endpos != 0) {
      this.jj_expentry = new int[this.jj_endpos];
      for (int i = 0; i < this.jj_endpos; i++) {
        this.jj_expentry[i] = this.jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator it = this.jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[]) (it.next());
        if (oldentry.length == this.jj_expentry.length) {
          for (int i = 0; i < this.jj_expentry.length; i++) {
            if (oldentry[i] != this.jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          this.jj_expentries.add(this.jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0)
        this.jj_lasttokens[(this.jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  public ParseException generateParseException() {
    this.jj_expentries.clear();
    boolean[] la1tokens = new boolean[34];
    if (this.jj_kind >= 0) {
      la1tokens[this.jj_kind] = true;
      this.jj_kind = -1;
    }
    for (int i = 0; i < 23; i++) {
      if (this.jj_la1[i] == this.jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1 << j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1 << j)) != 0) {
            la1tokens[32 + j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 34; i++) {
      if (la1tokens[i]) {
        this.jj_expentry = new int[1];
        this.jj_expentry[0] = i;
        this.jj_expentries.add(this.jj_expentry);
      }
    }
    this.jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[this.jj_expentries.size()][];
    for (int i = 0; i < this.jj_expentries.size(); i++) {
      exptokseq[i] = (int[]) this.jj_expentries.get(i);
    }
    return new ParseException(this.token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {}

  /** Disable tracing. */
  final public void disable_tracing() {}

  private void jj_rescan_token() {
    this.jj_rescan = true;
    for (int i = 0; i < 1; i++) {
      try {
        JJCalls p = this.jj_2_rtns[i];
        do {
          if (p.gen > this.jj_gen) {
            this.jj_la = p.arg;
            this.jj_lastpos = this.jj_scanpos = p.first;
            switch (i) {
            case 0:
              jj_3_1();
              break;
            }
          }
          p = p.next;
        } while (p != null);
      } catch (LookaheadSuccess ls) {
      }
    }
    this.jj_rescan = false;
  }

  private void jj_save(int index, int xla) {
    JJCalls p = this.jj_2_rtns[index];
    while (p.gen > this.jj_gen) {
      if (p.next == null) {
        p = p.next = new JJCalls();
        break;
      }
      p = p.next;
    }
    p.gen = this.jj_gen + xla - this.jj_la;
    p.first = this.token;
    p.arg = xla;
  }

  static final class JJCalls {
    int gen;

    Token first;

    int arg;

    JJCalls next;
  }

  public void setTermDocsFactory(TermDocsFactory termDocsFactory) {
    this.termDocsFactory = termDocsFactory;

  }

}
